

## 💡 Django란? 

![image](https://user-images.githubusercontent.com/99783474/193728776-4352cfef-9734-465b-a80a-c8a0f47302f5.png)

> Django 라는 이름은 홀로바티가 좋아하던 집시 재즈 기타리스트인 장고 라인하르트에서 따온 것이다.
>
> ![image](https://user-images.githubusercontent.com/99783474/193728822-5294db07-4142-4346-9796-727c3037aea8.png)
>
> **파이썬으로 작성된 오픈 소스 웹 프레임워크**로, 모델-템플릿-뷰 패턴을 따르고 있다. 
>
> * 목표 : 고도의 데이터베이스기반 웹사이트를 작성하는 데 있어서 수고를 더는 것이 장고의 주된 목표
> * **재사용성(reusability)**과 플러그인화 **가능성(pluggability)**, 빠른 개발 등을 강조



#### 🧐 모델 - 템플릿-뷰 패턴을 따르고 있다고? 

* **모델** 
  * 데이터에 관한 정보를 담는 그릇
  * 데이터에 대한 **접근, 검증, 작동과 데이터 사이의 관계를 정의** 
  * 일반적으로 각각의 모델은 **데이터베이스에서 테이블**에 해당
  * ![image](https://user-images.githubusercontent.com/99783474/193728865-2c170e8e-6c00-4642-97cf-4872bfc6f0c3.png)
  * Django에서는 모델을 정의할 떄 **필드의 종류를 지정**해 줘야한다. 
  * 데이터베이스에게 **컬럼 타입을 알려주고 HTML 폼으로 표시** 될때의 **입력 타입도 내포하는 역할**을 한다.
  * 장고의 **폼 자동 생성 API를 이용할 때 데이터 검증**에 사용하기도 한다. 



* **뷰**

  * 어떠한 데이터가 표시될 것인지 정의 

  * HTTP 응답 (response)를 반환해야 한다. 

    * HTTP 응답 (response) 는 처리한 결과를 웹 브라우저에게 전송하는 역할을 수행하는 클래스

    * **HTTP message** : 서버와 클라이언트 간의 데이터가 교환되는 방식 

     ![image](https://user-images.githubusercontent.com/99783474/193728902-73483f93-a98c-42d5-8b65-d2c39c03e2bb.png)

      * **HTTP 요청** : 클라이언트가 서버로 전달해서 서버의 액션이 일어나게끔 하는 메시지 

        ![image](https://user-images.githubusercontent.com/99783474/193728928-5328c0c7-7342-4b5a-92e5-4722dd0cc0ed.png)

        ​		◾ 메서드(Method) : 클라이언트가 서버에 요청할 동작 

        ​		◾ 프로토콜(Protocol) : 사용되는 포로토콜과 버전 

        ​		◾ 헤더 (Headers) : 클라이언트 자체에 대한 자세한 정보 

        ​		◾ empty-line : 헤더와 본문을 구분

        ​		◾ 본문(body) : 해당 요청 전송하는 메시지(data) (get 메서드로 요청을 보내는 경우  생략)

      * HTTP 요청메소드(클라이언트가 웹 서버에게 사용자 요청의 목적/ 종류를 알리는 수단) 

        : **get, post, put, patch, delete, options**

        * get `특정 리소스를 가져오도록 요청하는 메서드` `데이터를 가져올 때만 사용`  `URL 뒤에 데이터를 붙여 보냄`

          > www.example.com/upper

        * post `새로운 리소스 생성(create) 할 때 사용`  ` BODY에다 리소스를 넣어서 보냄`

        * put `POST와 비슷하지만 연속적인 요청시에도 같은 효과` `기존 데이터 교체 용도(update)`

        * patch`리소스의 부분적인 수정(update)을 할 때에 사용` 

        * delete `지정한 리소스를 삭제(delete) 요청`

        * options `사전 요청을 보내 서버가 해당 parameters를 포함한 요청을 보내도 되는지에 대한 응답` `응답 메세지에 HTTP 헤더 항목 중 'Allow: GET, POST, HEAD'처럼 보내게 된다`

        **<span style="color:red">※ HTTP Method 멱등성????</span>** 

        > 동일한 요청을 한번 보내는 것과, 여러 번 보내는 것이 서로 동일한 효과를 지니고, 서버의 상태도 동일하게 남을 때 해당 HTTP Method가 멱등성을 갖는다. 
        >
        > 멱등성은 서버의 상태만 바라보면 되며, HTTP 응답 Status는 신경쓰지 않아도 된다.

        > * **왜 멱등성을 가지게 설계해야 할까?**
        >
        > 1) functional programming을 고려한 설계가 저절로 이뤄진다는 것
        > 2) 양방향 통신을 할 필요가 없어 신뢰도가 높고 실행 속도가 빠르다는 것

        > * **멱득성에 대한 실용적인 예시**
        >
        > (1) 모든 유저의 '좋아요' 상태는 기본적으로 false이다. 
        >
        > (2) 유저가 사이트를 방문하면 기존에 '좋아요'를 눌렀는지 여부를 브라우저로 전송한다. 
        >
        > (3) 브라우저에서 유저가 버튼을 누른다. 
        >
        > (4) 서버로 `clickLike` 요청이 전송된다. 
        >
        > (5) 서버는 `clickLike` 요청을 받으면 DB에서 '좋아요' 상태를 반전한다. 
        >
        > (6) 브라우저에서 버튼의 상태를 반전한다. 

        ![image](https://user-images.githubusercontent.com/99783474/193728964-5f66cf88-e7f9-4930-af4f-f7f0e7683da6.png)

        * **HTTP 응답** : 요청에 대한 서버의 답변 

         ![image](https://user-images.githubusercontent.com/99783474/193728996-152b8b01-ca85-4395-b2ec-c238d052cab7.png)

          ​     ◾ 프로토콜(Version of the protocol) : 사용되는 프로토콜과 버전 

          ​     ◾ 상태코드(StateCode) : 요청에 대한 응답 상태 (요청에 대한 응답이 성공했는가?)

          ​		100 ~ 109 : 메세지 정보 

          ​		**<span style="color:red">200 ~ 206 : 요청 성공 </span>**

          ​		300 ~ 305 : 리 다이렉션 

          ​		**<span style="color:red">400 ~ 415 : 클라이언트 에러 </span>**

          ​		**<span style="color:red">500 ~ 505 : 서버 에러 </span>**

          

          

  * 응답 (response) 종류 : 웹 페이지, 리디렉션, 문서 등의 다양한 형태 가능 



----



#### 🧐 클라이언트(요청_고객)와 서버(응답__서비스제공) 구조 

---

![image](https://user-images.githubusercontent.com/99783474/193729044-69ea38b2-f80d-4182-baa3-eb2076f3032f.png)

---

* 웹 서비스는 클라이언트와 서버 구조를 기반으로 동작한다. 

* 클라이언트와 서버의 상호작용은 다음과 같다. ![image](https://user-images.githubusercontent.com/99783474/193729115-978adda4-fc56-4ff9-8ee2-f98c21a56a83.png)

  ##### Client (서비스를 요청)

  * 웹 사용자의 인터넷에 연결된 장치 (예를 들어 wi-fi에 연결된 컴퓨터 또는 모바일)

* Chrome 또는 Firefox와 같은 웹 브라우저 ( 웹브라우저인 크롬, 파이어폭스, 익스플로러를 **'웹 클라이언트'** 라고 한다.)

  * 서비스를 요청하는 주체

  ##### Server (서비스를 제공)

  * 웹 페이지, 사이트 또는 앱을 저장하는 컴퓨터

* 클라이언트가 웹 페이지에 접근하려고 할 때 서버에서 클라이언트 컴퓨터로 웹 페이지 데이터를 응답해 사용자의 웹 브라우저에 표시됨

  * 요청에 대해 서비스를 응답하는 주체
  * 클라이언트와 서버의 통신


### ✔ [클라이언트와 서버의 통신]![image](https://user-images.githubusercontent.com/99783474/193729191-340d6c4a-db76-4d2c-9b22-3afd868fb5e6.png)

> 일반적으로 네트워크 서비스를 바딕 위해 클라이언트가 통신을 시작합니다. 클라이언트는 서버에 접속을 시도하고 그 연결 결과를 기다리거나, 어떤 서비스를 요구하고 응답을 기다립니다. 
>
> 클라이언트의 이와 같은 요구에 대하여 서버가 응답을 보내는 방식으로 동작이 이루어집니다. 

* **클라이언트와 서버의 통신 방식**

**(1)  Polling방식**

> **클라이언트가 서버에 주기적으로 요청 후 응답을 받는 형식**이다. 
>
> 클라이언트가 주기적으로 요청을 하기 때문에 클라이언트의 수가 증가하면 요청의 수도 증가하기 때문에 서버의 부담이 커지고, 요청과 응답후에는 연결이 끊어지기 때문에 요청할 때마다 연결을 맺는 과정이 필요해서 많은 비용이 소모될 수 있다. 

**(2)  Long Poll방식**

> **클라이언트가 서버에 대한 요청을 유지하여 반복적인 요청을 없애고 유효한 이벤트가 발생하면 응답을 해주는 방식**이다. 
>
> 불필요한 요청에 계속 응답하는 것이 아니기 때문에 요청에 따른 커넥션 과정에서 비용이 절감된다. 하지만, 클라이언트의 수가 증가하면 그에 따를 응답을 해야하는 수도 증가하기 때문에 Polling과 큰 차이는 없게 된다. 또, 다수의 클라이언트에서 동시에 이벤트가 발생할 경우 서버는 각 클라이언트에 응답을 하게되고, 그 다수의 클라이언트는 서버에게 곧바로 요청을 하므로 이때 서버의 부담이 커질 수 있다. 

**(3) WebSocket방식**

> 웹소켓은 HTML5 표준 기술로, Client와 서버가 연결된 후부터 HTTP 요청, 응답과는 상관없이 서버와 **양방향 통신이 가능**하다.
>
> 채팅, 게임, 실시간 주식차트와 같은 실시간이 요구되는 응용프로그램 개발에 사용가능하다.



---



### 💡 Django 구조 이해하기 (MTV Design Pattern)

> **MTV** : **Django 에 적용된 디자인 패턴** (MVC 디자인 패턴을 기반으로 조금 변형된 패턴)
>
> ![image](https://user-images.githubusercontent.com/99783474/193729246-ab845bc6-b858-462e-a031-0047758b3815.png)

* **MVC는 Model - View – Controller의 준말**

  > 데이터 및 논리 제어를 구현하는데 널리 사용되는 소프트웨어 디자인 패턴

* **하나의 큰 프로그램을 3가지 역할로 구분한 개발 방법론**

> * **Model : 데이터와 관련된 로직을 관리**
>
> * **View : 레이아웃과 화면을 처리**
>
> * **Controller : 명령을 model과 view 부분으로 연결**



#### 👉 MVC 소프트웨어 디자인 패턴의 목적 

* 더 나은 업무의 분리와 향상된 관리를 제공
* 각 부분을 독립적으로 개발할 수 있어, 하나를 수정하고 싶을 때 모두 건들지 않아도 됨
  * == 개발 효율성 및 유지보수가 쉬워짐
  * == 다수의 멤버로 개발하기 용이함

|    MVC     |   MTV    |
| :--------: | :------: |
|   Model    |  Model   |
|    View    | Template |
| Controller |   View   |



##### ✔ Model

* MVC 패턴에서 Model의 역할에 해당
* 데이터와 관련된 로직을 관리 
* 응용프로그램의 데이터 구조를 정의하고 데이터 베이스의 기록을 관리 



##### ✔ Template

* 레이아웃과 화면을 처리 
* 화면상의 사용자 인터페이스 구조와 레이아웃을 정의 
* MVC 패턴에서 view 의 역할에 해당 



#####  ✔ View

* model & template과 관련한 로직을 처리해서 응답을 반환 
* 클라이언트의 요청에 대해 처리를 분기하는 역할 
* 동작 예시 
  * 데이터가 필요하다면 model에 접근해서 데이터를 가져오고 가져온 데이터를 template로 보내 화면을 구성하고 구성된 화면을 응답으로 만들어 클라이언트에게 반환 
  * MVC 패턴에서 Controller의 역할에 해당 



---

#### [MVT(Model-View-Template)](https://velog.io/@inyong_pang/Programming-MVCMTV-%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4)

![image](https://user-images.githubusercontent.com/99783474/193729284-ff7e276d-d846-4f50-b2cd-be8e9b8bdac6.png)

* **MVT 처리과정**
  * 클라이언트로 부터 요청을 받으면 `URLconf`를 이용하여 URL 을 분석
  * URL 분석 결과를 통해 해당 URL 에 대한 처리를 담당할 View 를 결정
  * View 는 자신의 로직을 실행 하면서 만일 데이터 베이스 처리가 필요하면 해당 모델에 요청하고 그 결과를 반환받음
  * View 는 자신의 로직 처리가 끝나면 Template 을 사용하여 클라이언트에 전송할 HTML 파일을 생성
  * View 는 최종 결과로 HTML 파일을 클라이언트에 보내어 응답



* **Django는 MTV 디자인 패턴을 가지고 있음**

  * Model : 데이터 관련
  * Template : 화면 관련
  * View : Model & Template 중간 처리 및 응답 반환

  

---





#### 🧐 Design Pattern 이란? 

![image](https://user-images.githubusercontent.com/99783474/193729312-63e42e3d-2904-43eb-9a4b-ab56605a542a.png)

* 광안대교 같은 다리를 현수교(Suspension Bridge) 라고 함
* 교량의 양쪽 끝과 가운데 솟아있는 주탑에 케이블을 두고 상판을 메다는 형식의 공법
* 이와 똑같은 방식을 사용해서 인천대교, 이순신대교 등이 만들어졌음
* 즉, 여러 번 짓다보니 자주 사용되는 구조가 있다는 것을 알게 되었고 이를 일반화해서 하나의 공법으로 만들어 둔 것 



#### 👉 소프트웨어 에서의 관점 

> **각기 다른 기능을 가진 다양한 응용 소프트웨어를 개발할 때 공통적인 설계 문제가 존재하며 , 이를 처리하는 해결책 사이에도 공통점이 있다는 것을 발견 **



#### 👉소프트웨어 디자인 패턴

> * 소프트웨어도 수십년간 전 세계의 개발자들이 계속 만들다 보니 자주 사용되는 구조와 해결책이 있다는 것을 알게 됨 
> * 앞서 배웠던 클라이언트-서버 구조도 소프트웨어 디자인 패턴 중 하나 
> * 자주 사용되는 소프트웨어의 구조를 소수의 뛰어난 엔지니어가 마치 건축의 공법처럼 일반적인 구조화를 해둔 것 



#### 👉소프트웨어 디자인 패턴 목적

> * 특정 문맥에서 공통적으로 발생하는 문제에 대해 재사용 가능한 해결책을 제시 
> * 프로그래머가 어플리케이션이나 시스템을 디자인할 때 발생하는 공통된 문제들을 해결하는데 형식화 된 가장 좋은 관행



#### 👉소프트웨어 디자인 패턴 장점 

> 디자인 패턴을 알고 있다면 **서로 복잡한 커뮤니케이션이 매우 간단해짐**
>
> "우리 이거 클라이언트 - 서버 구조로 구현하자"
>
> > 다수의 엔지니어들이 일반화된 패턴으로 소프트웨어 개발을 할 수 있도록 한 규칙, 커뮤니케이션의 효율성을 높이는 기법 



---



#### ✔ 정적 웹 페이지

![image](https://user-images.githubusercontent.com/99783474/193729345-bac9d3d6-9612-48be-8483-aca39ea2b8c9.png)

* 있는 그대로를 제공하는 것 _ SERVED AS-IS 을 의미 

* 우리가 지금까지 작성한 웹 페이지이며 한 번 작성된 HTML 파일의 내용이 변하지 않고 

  모든 사용자에게 동일한 모습으로 전달되는 것

  * == 서버에 미리 저장된 HTML  파일 그대로 전달된 웹 페이지 
  * == 같은 상황에서 모든 사용자에게 동일한 정보를 표시 



#### ✔ 동적 웹 페이지 

* Dynamic Web page

* 사용자의 요청에 따라 웹 페이ㅣ지에 추가적인 수정이 되어 클라이언트에게 전달되는 웹 페이지 

* 웹 페이지의 내용을 바꿔주는 주체 == 서버 

  * 서버에서 동작하고 있는 프로그램이 웹 페이지를 변경해줌 

  * 사용자의 요청을 받아서 적절한 응답을 만들어 주는 프로그램을 쉽게 만들 수 있게 도와주는 

    프레임워크가 바로 우리가 배울 **장고!**

* 다양한 서버 사이드 프로그래밍 언어 사용 가능하고 파일을 처리하고 데이터베이스와의 상호작용이 이루어짐

* python을 이용해서 개발할 수 있는 프레임워크인 장고를 학습하는 것! 



![image](https://user-images.githubusercontent.com/99783474/193729407-98670297-9250-45d1-b63e-b6de131ed1e9.png)



---

## [Django CRUD 기본적인 흐름 정리](https://github.com/oiosu/Django_CRUD)




